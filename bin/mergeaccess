#!/usr/bin/env perl

use strict;
use utf8;
use warnings;
use Getopt::Long;
use Config::General;
use CIHM::Meta::REST::access;
use CIHM::Meta::REST::collection;
use CIHM::Meta::REST::manifest;
use Data::Dumper;
use JSON;
use DateTime;
use List::Compare;
use Digest::MD5 qw(md5 md5_hex md5_base64);
use File::chdir;

my $conf = "/etc/canadiana/tdr/tdr.conf";
my $validate;
my $debug;

GetOptions(
    'conf:s'   => \$conf,
    'validate' => \$validate,
    'debug'    => \$debug
);

my %confighash = new Config::General( -ConfigFile => $conf, )->getall;

# Undefined if no <collection> config block
my $collectiondb;
if ( exists $confighash{collection} ) {
    $collectiondb = new CIHM::Meta::REST::collection(
        server      => $confighash{collection}{server},
        database    => $confighash{collection}{database},
        type        => 'application/json',
        conf        => $conf,
        clientattrs => { timeout => 36000 },
    );
}
else {
    die "Missing <collection> configuration block in config\n";
}

# Undefined if no <manifest> config block
my $manifestdb;
if ( exists $confighash{manifest} ) {
    $manifestdb = new CIHM::Meta::REST::manifest(
        server      => $confighash{manifest}{server},
        database    => $confighash{manifest}{database},
        type        => 'application/json',
        conf        => $conf,
        clientattrs => { timeout => 36000 },
    );
}
else {
    die "Missing <manifest> configuration block in config\n";
}

# Undefined if no <access> config block
my $accessdb;
if ( exists $confighash{access} ) {
    $accessdb = new CIHM::Meta::REST::access(
        server      => $confighash{access}{server},
        database    => $confighash{access}{database},
        type        => 'application/json',
        conf        => $conf,
        clientattrs => { timeout => 36000 },
    );
}
else {
    die "Missing <access> configuration block in config\n";
}

my $entriescount = 0;
my @accessentries;
my @aliases;

#my $res;
$| = 1;

## Load existing 'collection' entries
print "Load existing 'collection' entries...\n";

my $res = $collectiondb->get(
    "/" . $collectiondb->database . "/_all_docs?include_docs=true",
    {}, { deserializer => 'application/json' } );
if ( $res->code != 200 ) {
    if ( defined $res->response->content ) {
        warn $res->response->content . "\n";
    }
    die $collectiondb->database
      . "/_all_docs return code: "
      . $res->code . "\n";
}
foreach my $collection ( @{ $res->data->{rows} } ) {
    if ( substr( $collection->{key}, 0, 8 ) ne '_design/' ) {
        processEntry( "collection", $collection->{doc} );
    }
}
saveEntries();

## Load existing 'manifest' entries
print "Load existing 'manifest' entries...\n";

my $done = 0;

my $startkey;

#my $startkey="69429/m04t6f18ss85";
#my $startkey = "69429/m0zw18k7959f";
my $limit = 100;
while ( !$done ) {

    my $url = "/"
      . $manifestdb->database
      . "/_all_docs?include_docs=true&limit="
      . ( $limit + 1 );
    if ($startkey) {
        $url .= "&startkey=" . encode_json($startkey);
    }

    print "url: $url\n";

    $res = $manifestdb->get( $url, {}, { deserializer => 'application/json' } );
    if ( $res->code != 200 ) {
        if ( defined $res->response->content ) {
            warn $res->response->content . "\n";
        }
        die $url . " return code: " . $res->code . "\n";
    }
    my $rowcount = scalar( @{ $res->data->{rows} } );

    if ( $rowcount > $limit ) {
        $startkey = $res->data->{rows}->[ $rowcount - 1 ]->{key};
        $rowcount--;
    }
    else {
        $done = 1;
    }
    print "EntriesCount: $entriescount Rowcount: $rowcount  "
      . "Limit:$limit Done: $done "
      . ( $startkey ? "StartKey: $startkey" : "" ) . "\n";

    for ( 0 .. ( $rowcount - 1 ) ) {
        my $collection = $res->data->{rows}->[$_];
        if ( substr( $collection->{key}, 0, 8 ) ne '_design/' ) {
            processEntry( "manifest", $collection->{doc} );
        }
    }
    saveEntries();
}

print "Entries: $entriescount\n";
print Dumper ( \@aliases );

@accessentries = @aliases;
saveEntries();

exit 0;

###########

# Pass hash of entries
sub processEntry {
    my ( $type, $entry ) = @_;

    my $noid = $entry->{'_id'};
    delete $entry->{'_rev'};
    my $manifesttype = $entry->{type};
    $entry->{type} = $type;

    # Slug is mandatory
    if ( !exists $entry->{slug} ) {
        $entry->{slug} = ".";
    }

    # Old stuff that sholdn't be there
    delete $entry->{'updated'};

    # Leave 'public' and 'updateInternalmeta' alone

    # leave 'slug' alone, but separate out 'aliasedSlugs'
    if ( exists $entry->{aliasedSlugs} ) {
        foreach my $alias ( @{ $entry->{aliasedSlugs} } ) {
            push @aliases, { slug => $alias, type => 'alias', to => $noid };
        }
        delete $entry->{aliasedSlugs};
    }

    if (   exists $entry->{updateInternalmeta}
        && exists $entry->{updateInternalmeta}->{succeeded} )
    {
        $entry->{updateInternalmeta}->{succeeded} =
            ( $entry->{updateInternalmeta}->{succeeded} )
          ? (JSON::true)
          : (JSON::false);
    }

    # Move from IIIF
    if ( exists $entry->{label} ) {
        $entry->{label} = IIIF2txt( $entry->{label} );
    }
    if ( exists $entry->{summary} ) {
        $entry->{summary} = IIIF2txt( $entry->{summary} );
    }

    # Behaviour is new, so set to default for type
    if ( $type eq 'collection' ) {
        $entry->{behavior} =
          ( $entry->{'ordered'} ) ? "multi-part" : "unordered";
        delete $entry->{'ordered'};
    }
    else {
        $entry->{viewingDirection} = "top-to-bottom";
        $entry->{behavior}         = "contiuous";
    }

    # This only exists for a collection
    if ( exists $entry->{items} ) {

        # since items[].itemLabel never used, don't need to transform
        $entry->{members} = $entry->{items};
        delete $entry->{items};
    }

    # Manifests

    # Never implimented, so clean out
    delete $entry->{frozen};
    delete $entry->{freezeParameters};

    if ( $manifesttype && ( $manifesttype eq "multicanvas" ) ) {
        $entry->{from} = "canvases";

        # convert labels
        if ( exists $entry->{canvases} ) {
            for ( 0 .. ( @{ $entry->{canvases} } - 1 ) ) {
                my $i = $_;
                if ( exists $entry->{canvases}->[$i]->{label} ) {
                    $entry->{canvases}->[$i]->{label} =
                      IIIF2txt( $entry->{canvases}->[$i]->{label} );
                }
            }
        }
    }

    if ( $manifesttype && ( $manifesttype eq "pdf" ) ) {
        $entry->{from} = "pdf";
        $entry->{file} = $entry->{master};
        delete $entry->{master};
        if ( exists $entry->{masterPages} ) {
            $entry->{pageLabels} = [];
            for ( 0 .. ( @{ $entry->{masterPages} } - 1 ) ) {
                my $i = $_;
                $entry->{pageLabels}->[$i] =
                  IIIF2txt( $entry->{masterPages}->[$i] );
            }
            delete $entry->{masterPages};
        }
    }

    #  print Dumper($entry);
    push @accessentries, $entry;
    print ".";
}

sub saveEntries {
    if ($validate) {
        foreach my $entry (@accessentries) {
            validateRecord( 'access', $entry );
        }
    }

    $entriescount += scalar(@accessentries);
    print "-->EntriesCount: $entriescount\n";
    @accessentries = ();

}

sub IIIF2txt {
    my ($iiifTxt) = @_;

    foreach my $lang ( keys %{$iiifTxt} ) {
        $iiifTxt->{$lang} = pop @{ $iiifTxt->{$lang} };
    }
    return $iiifTxt;
}

# Validation, temporarily using a temporary file and calling kivik from the command line.
sub validateRecord {
    my ( $database, $record ) = @_;

    my $tempname = "/tmp/mergeaccessvalidate.json";

    open( FH, '>', $tempname ) or die $!;
    print FH encode_json($record);
    close(FH);

    local $CWD = "/home/tdr/Access-Platform/couchdb";

    my $results;
    open( FH, "pnpx kivik validate $database $tempname |" )
      or die $!;
    {
        local $/;
        $results = <FH>;
    }
    close(FH);
    chomp($results);

    # Currently looks for specific string rather than return code.
    # There will eventually be a REST call, so this is all temporary.
    if ( !( $results =~ /validates against database/ ) ) {
        print "Validation failure for database=$database :\n"
          . Data::Dumper->Dump( [ $record, $results ], [qw(Record Result)] )
          . "\n";
    }
}
